# 简单动态字符串

## SDS的定义

每个sds.h/sdshdr结构表示一个SDS值：

```c
struct adshdr{
	//记录bug数组中已使用字节的数量
	//等于SDS所保存字符串的长度
	int len;
	//记录buf数组中未使用字节的数量
	int free;
	//字节数组，用于保存字符串
	char buf[]
};
```

(https://github.com/caicancai/redis-coding/blob/main/img/5520a4a26ce6d18b82175284ecfaf57.jpg)

示例：

> - free属性的值为0，表示这个SDS没有分配任何未使用空间
> - len属性的值为5，表示这个SDS保存了四字节长的字符串
> - buf属性是一个char类型的数组

SDS遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面，并且为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操作，都是由SDS函数自动完成的，所以这个空字符对于SDS的使用者来说是完全透明的。（遵循空字符结尾这一惯例的好处是，SDS可以直接重用一部分C字符串函数库里面的函数）。

## SDS与C字符串的区别

### 常数复杂度获取字符串长度

因为C字符串并不记录自身的长度信息，所以为了获取一个C字符串的长度，程序必须遍历整个字符串，这样复杂度为O（N）。

和C字符串不同，因为SDS在len属性中记录了SDS本身的长度，所以获取一个SDS长度的复杂度为O（1）

优点：通过使用SDS而不是C字符串，确保了字符串长度不会成为Redis的性能瓶颈

### 杜绝缓冲区溢出

#### 什么是缓冲区溢出

举个例子，strcat函数可以将src字符串中的内容拼接到dest字符串的末尾：

```c
char *strcat(char *dest,const char *src);
```

因为C字符不记录自身的长度，所以strcat假定用户在执行这个函数时，已经为dest分配足够多的内u你，可以容纳src字符串所有内容，而一旦这个假定不成立，就会产生缓冲区溢出。

与C字符串不同，SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性；当SDSAPI需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足的话，API会自动将SDS的空间扩展修改所需的大小，然后才执行实际的修改操作。

### 减少修改字符串时带来的内存重分配次数

因为C字符串的长度和底层数组的长度之间存在着这种联系，所以每次增长或者缩短一个C，程序都总要对保存这个C字符串的数组进行一次内存重分配操作：

> 如果程序执行的是增长字符串的操作，比如拼接操作，那么在执行这个操作之前，程序需要先通过内存重分配来拓展底层数组的空间大小——如果忘了这一步就会产生缓冲去溢出
>
> 如果程序执行的是缩短字符串的操作，比如截断操作，那么在执行这个操作之后，程序需要通过内存重分配来释放字符串不再使用那部分空间——如果到了这一步就会产生内存泄漏

Redis数据库，使用C字符串可能会对性能造成影响

#### 空间预分配

空间预分配用于优化SDS的字符串增长操作，当SDS的API对一个SDS进行修改，并且需要对SDS进行空间拓展的时候，程序不仅会为SDS分配修改所必须要的空间，还会为SDS分配额外的未使用空间

分配公式：

> 如果对SDS进行修改之后，SDS的长度将小于1MB，那么程序分配和len属性同样大小的未使用空间，这是SDS len属性的值将和free属性的值相同
>
> 如果对SDS进行修改之后，SDS的长度将大于或等于1MB，那么程序会分配1MB的未使用空间

通过空间预分配策略，Redis可以减少连续执行字符串增长操作所需的内存重分配次数。

在扩展SDS空间之前，SDS API会先检查未使用空间是否足够，如果足够的话，API就会直接使用未使用空间，而无须执行内存重分配。

通过这种预分配策略，SDS将连续增长N次字符串所需的内存重分配次数从必定N次降低为最多N次

#### 惰性空间释放

惰性空间释放用于优化SDS的字符串缩短操作，当SDS的API需要缩短SDS保存的字符串是，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free将这些字节的数量记录起来，并等待将来使用。

#### 二进制安全

使用二进制安全的SDS，而不是C字符串，使得Redis不仅可以保存文本数据，还可以保存任意格式的二进制数据

#### 兼容部分C字符串函数
